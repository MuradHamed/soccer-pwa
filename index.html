import React, { createContext, useContext, useReducer, useState, useEffect } from 'react';

// Supabase client configuration
const supabaseUrl = 'https://rqpcxbzfvufekaihnmct.supabase.co';
const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJxcGN4YnpmdnVmZWthaWhubWN0Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDkyMzA4NTAsImV4cCI6MjA2NDgwNjg1MH0.mo6COppydSth-qsLGmREFP1yETVpGH1f3CBXbhKDs4M';

// Simple Supabase client implementation using fetch
const supabase = {
  from: (table) => ({
    select: (columns = '*') => ({
      order: (column, options) => ({
        then: async (callback) => {
          try {
            const response = await fetch(`${supabaseUrl}/rest/v1/${table}?select=${columns}&order=${column}.${options.ascending ? 'asc' : 'desc'}`, {
              headers: {
                'apikey': supabaseKey,
                'Authorization': `Bearer ${supabaseKey}`,
                'Content-Type': 'application/json'
              }
            });
            const data = await response.json();
            callback({ data: response.ok ? data : [], error: response.ok ? null : data });
          } catch (error) {
            callback({ data: [], error });
          }
        }
      }),
      then: async (callback) => {
        try {
          const response = await fetch(`${supabaseUrl}/rest/v1/${table}?select=${columns}`, {
            headers: {
              'apikey': supabaseKey,
              'Authorization': `Bearer ${supabaseKey}`,
              'Content-Type': 'application/json'
            }
          });
          const data = await response.json();
          callback({ data: response.ok ? data : [], error: response.ok ? null : data });
        } catch (error) {
          callback({ data: [], error });
        }
      }
    }),
    insert: (data) => ({
      select: () => ({
        single: () => ({
          then: async (callback) => {
            try {
              const response = await fetch(`${supabaseUrl}/rest/v1/${table}`, {
                method: 'POST',
                headers: {
                  'apikey': supabaseKey,
                  'Authorization': `Bearer ${supabaseKey}`,
                  'Content-Type': 'application/json',
                  'Prefer': 'return=representation'
                },
                body: JSON.stringify(data[0])
              });
              const result = await response.json();
              callback({ 
                data: response.ok ? result : null, 
                error: response.ok ? null : result 
              });
            } catch (error) {
              callback({ data: null, error });
            }
          }
        })
      })
    }),
    delete: () => ({
      eq: (column, value) => ({
        then: async (callback) => {
          try {
            const response = await fetch(`${supabaseUrl}/rest/v1/${table}?${column}=eq.${value}`, {
              method: 'DELETE',
              headers: {
                'apikey': supabaseKey,
                'Authorization': `Bearer ${supabaseKey}`,
                'Content-Type': 'application/json'
              }
            });
            callback({ error: response.ok ? null : await response.json() });
          } catch (error) {
            callback({ error });
          }
        }
      })
    })
  })
};

// State Management with Context
const AppContext = createContext();

const initialState = {
  players: [],
  orangeTeam: [],
  greenTeam: [],
  loading: false,
  error: null
};

function appReducer(state, action) {
  switch (action.type) {
    case 'SET_LOADING':
      return { ...state, loading: action.payload };
    case 'SET_ERROR':
      return { ...state, error: action.payload, loading: false };
    case 'SET_PLAYERS':
      return { ...state, players: action.payload, loading: false };
    case 'SET_TEAMS':
      return { 
        ...state, 
        orangeTeam: action.payload.orange,
        greenTeam: action.payload.green,
        loading: false 
      };
    case 'ADD_PLAYER_LOCAL':
      return {
        ...state,
        players: [...state.players, action.payload]
      };
    case 'REMOVE_PLAYER_LOCAL':
      return {
        ...state,
        players: state.players.filter(p => p.id !== action.payload),
        orangeTeam: state.orangeTeam.filter(p => p.id !== action.payload),
        greenTeam: state.greenTeam.filter(p => p.id !== action.payload)
      };
    case 'UPDATE_TEAMS_LOCAL':
      return {
        ...state,
        orangeTeam: action.payload.orange,
        greenTeam: action.payload.green
      };
    default:
      return state;
  }
}

function AppProvider({ children }) {
  const [state, dispatch] = useReducer(appReducer, initialState);
  
  // Load initial data from Supabase
  const loadData = async () => {
    try {
      dispatch({ type: 'SET_LOADING', payload: true });
      
      // Load players
      const { data: players, error: playersError } = await supabase
        .from('players')
        .select('*')
        .order('created_at', { ascending: true });
      
      if (playersError) {
        console.error('Players error:', playersError);
        throw playersError;
      }
      
      // Load teams
      const { data: teams, error: teamsError } = await supabase
        .from('teams')
        .select('player_id, team_color');
      
      if (teamsError) {
        console.error('Teams error:', teamsError);
        throw teamsError;
      }
      
      // Organize teams
      const orangeTeam = [];
      const greenTeam = [];
      
      teams?.forEach(team => {
        const player = players?.find(p => p.id === team.player_id);
        if (player) {
          if (team.team_color === 'orange') {
            orangeTeam.push(player);
          } else {
            greenTeam.push(player);
          }
        }
      });
      
      dispatch({ type: 'SET_PLAYERS', payload: players || [] });
      dispatch({ type: 'SET_TEAMS', payload: { orange: orangeTeam, green: greenTeam } });
      
    } catch (error) {
      console.error('Error loading data:', error);
      dispatch({ type: 'SET_ERROR', payload: `Database connection error: ${error.message}` });
      
      // Fallback to localStorage if Supabase fails
      const savedPlayers = localStorage.getItem('soccer-players');
      const savedTeams = localStorage.getItem('soccer-teams');
      
      if (savedPlayers) {
        dispatch({ type: 'SET_PLAYERS', payload: JSON.parse(savedPlayers) });
      }
      
      if (savedTeams) {
        const teams = JSON.parse(savedTeams);
        dispatch({ type: 'SET_TEAMS', payload: teams });
      }
    }
  };

  useEffect(() => {
    loadData();
  }, []);

  const saveToStorage = (players, teams) => {
    localStorage.setItem('soccer-players', JSON.stringify(players));
    localStorage.setItem('soccer-teams', JSON.stringify(teams));
  };

  const addPlayer = async (name) => {
    try {
      const { data, error } = await supabase
        .from('players')
        .insert([{ name }])
        .select()
        .single();
      
      if (error) throw error;
      
      dispatch({ type: 'ADD_PLAYER_LOCAL', payload: data });
      
      // Backup to localStorage
      const updatedPlayers = [...state.players, data];
      saveToStorage(updatedPlayers, { orange: state.orangeTeam, green: state.greenTeam });
      
    } catch (error) {
      dispatch({ type: 'SET_ERROR', payload: error.message });
      console.error('Error adding player:', error);
      
      // Fallback to localStorage
      const newPlayer = { id: Date.now(), name, created_at: new Date().toISOString() };
      const updatedPlayers = [...state.players, newPlayer];
      
      dispatch({ type: 'ADD_PLAYER_LOCAL', payload: newPlayer });
      saveToStorage(updatedPlayers, { orange: state.orangeTeam, green: state.greenTeam });
    }
  };

  const removePlayer = async (playerId) => {
    try {
      // Remove from teams first
      await supabase.from('teams').delete().eq('player_id', playerId);
      
      // Remove player
      const { error } = await supabase.from('players').delete().eq('id', playerId);
      if (error) throw error;
      
      dispatch({ type: 'REMOVE_PLAYER_LOCAL', payload: playerId });
      
      // Backup to localStorage
      const updatedPlayers = state.players.filter(p => p.id !== playerId);
      const updatedOrange = state.orangeTeam.filter(p => p.id !== playerId);
      const updatedGreen = state.greenTeam.filter(p => p.id !== playerId);
      saveToStorage(updatedPlayers, { orange: updatedOrange, green: updatedGreen });
      
    } catch (error) {
      dispatch({ type: 'SET_ERROR', payload: error.message });
      console.error('Error removing player:', error);
      
      // Fallback to localStorage
      const updatedPlayers = state.players.filter(p => p.id !== playerId);
      const updatedOrange = state.orangeTeam.filter(p => p.id !== playerId);
      const updatedGreen = state.greenTeam.filter(p => p.id !== playerId);
      
      dispatch({ type: 'REMOVE_PLAYER_LOCAL', payload: playerId });
      saveToStorage(updatedPlayers, { orange: updatedOrange, green: updatedGreen });
    }
  };

  const moveToTeam = async (playerId, teamColor) => {
    try {
      const player = state.players.find(p => p.id === playerId);
      if (!player) return;
      
      // Remove from current team
      await supabase.from('teams').delete().eq('player_id', playerId);
      
      // Add to new team
      const { error } = await supabase
        .from('teams')
        .insert([{ player_id: playerId, team_color: teamColor }]);
      
      if (error) throw error;
      
      // Update local state
      let updatedOrange = state.orangeTeam.filter(p => p.id !== playerId);
      let updatedGreen = state.greenTeam.filter(p => p.id !== playerId);
      
      if (teamColor === 'orange') {
        updatedOrange = [...updatedOrange, player];
      } else {
        updatedGreen = [...updatedGreen, player];
      }
      
      dispatch({ 
        type: 'UPDATE_TEAMS_LOCAL', 
        payload: { orange: updatedOrange, green: updatedGreen } 
      });
      
      // Backup to localStorage
      saveToStorage(state.players, { orange: updatedOrange, green: updatedGreen });
      
    } catch (error) {
      dispatch({ type: 'SET_ERROR', payload: error.message });
      console.error('Error moving player to team:', error);
      
      // Fallback to localStorage
      const player = state.players.find(p => p.id === playerId);
      if (!player) return;
      
      let updatedOrange = state.orangeTeam.filter(p => p.id !== playerId);
      let updatedGreen = state.greenTeam.filter(p => p.id !== playerId);
      
      if (teamColor === 'orange') {
        updatedOrange = [...updatedOrange, player];
      } else {
        updatedGreen = [...updatedGreen, player];
      }
      
      dispatch({ 
        type: 'UPDATE_TEAMS_LOCAL', 
        payload: { orange: updatedOrange, green: updatedGreen } 
      });
      
      saveToStorage(state.players, { orange: updatedOrange, green: updatedGreen });
    }
  };

  const removeFromTeam = async (playerId) => {
    try {
      const { error } = await supabase.from('teams').delete().eq('player_id', playerId);
      if (error) throw error;
      
      const updatedOrange = state.orangeTeam.filter(p => p.id !== playerId);
      const updatedGreen = state.greenTeam.filter(p => p.id !== playerId);
      
      dispatch({ 
        type: 'UPDATE_TEAMS_LOCAL', 
        payload: { orange: updatedOrange, green: updatedGreen } 
      });
      
      // Backup to localStorage
      saveToStorage(state.players, { orange: updatedOrange, green: updatedGreen });
      
    } catch (error) {
      dispatch({ type: 'SET_ERROR', payload: error.message });
      console.error('Error removing from team:', error);
      
      // Fallback to localStorage
      const updatedOrange = state.orangeTeam.filter(p => p.id !== playerId);
      const updatedGreen = state.greenTeam.filter(p => p.id !== playerId);
      
      dispatch({ 
        type: 'UPDATE_TEAMS_LOCAL', 
        payload: { orange: updatedOrange, green: updatedGreen } 
      });
      
      saveToStorage(state.players, { orange: updatedOrange, green: updatedGreen });
    }
  };
  
  return (
    <AppContext.Provider value={{ 
      state, 
      dispatch,
      addPlayer,
      removePlayer,
      moveToTeam,
      removeFromTeam,
      loadData
    }}>
      {children}
    </AppContext.Provider>
  );
}

function useApp() {
  const context = useContext(AppContext);
  if (!context) {
    throw new Error('useApp must be used within AppProvider');
  }
  return context;
}

// Components
function NavBar() {
  return (
    <nav className="bg-gray-900 border-b border-gray-700 px-4 py-3">
      <h1 className="text-white text-xl font-bold text-center">âš½ Soccer Teams</h1>
    </nav>
  );
}

function TabBar({ activeTab, onTabChange }) {
  return (
    <div className="bg-gray-800 border-b border-gray-700">
      <div className="flex">
        <button 
          onClick={() => onTabChange('add-remove')}
          className={`flex-1 py-3 text-center font-medium transition-colors ${
            activeTab === 'add-remove' 
              ? 'text-blue-400 bg-gray-700 border-b-2 border-blue-400' 
              : 'text-gray-300 hover:text-white hover:bg-gray-700'
          }`}
        >
          Add / Remove
        </button>
        <button 
          onClick={() => onTabChange('teams')}
          className={`flex-1 py-3 text-center font-medium transition-colors ${
            activeTab === 'teams' 
              ? 'text-blue-400 bg-gray-700 border-b-2 border-blue-400' 
              : 'text-gray-300 hover:text-white hover:bg-gray-700'
          }`}
        >
          Teams
        </button>
      </div>
    </div>
  );
}

function ErrorBanner({ error, onDismiss }) {
  if (!error) return null;
  
  return (
    <div className="bg-red-900 border border-red-700 text-red-200 px-4 py-3 mx-4 mt-4 rounded-lg flex justify-between items-center">
      <span className="text-sm">{error}</span>
      <button 
        onClick={onDismiss}
        className="text-red-400 hover:text-red-200 ml-4 text-lg"
      >
        Ã—
      </button>
    </div>
  );
}

function AddRemoveTab() {
  const { state, addPlayer, removePlayer, dispatch } = useApp();
  const [inputValue, setInputValue] = useState('');

  const handleSubmit = async (e) => {
    e.preventDefault();
    if (inputValue.trim()) {
      await addPlayer(inputValue.trim());
      setInputValue('');
    }
  };

  const handleRemovePlayer = async (id) => {
    await removePlayer(id);
  };

  const handleKeyPress = (e) => {
    if (e.key === 'Enter') {
      handleSubmit(e);
    }
  };

  return (
    <div className="p-4 max-w-md mx-auto">
      <ErrorBanner 
        error={state.error} 
        onDismiss={() => dispatch({ type: 'SET_ERROR', payload: null })} 
      />
      
      <div className="mb-6">
        <div className="flex gap-2">
          <input
            type="text"
            value={inputValue}
            onChange={(e) => setInputValue(e.target.value)}
            onKeyPress={handleKeyPress}
            placeholder="Enter player name"
            disabled={state.loading}
            className="flex-1 px-4 py-3 bg-gray-800 text-white border border-gray-600 rounded-lg focus:outline-none focus:border-blue-500 focus:ring-1 focus:ring-blue-500 disabled:opacity-50"
          />
          <button
            onClick={handleSubmit}
            disabled={state.loading || !inputValue.trim()}
            className="px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors font-medium disabled:opacity-50 disabled:cursor-not-allowed"
          >
            {state.loading ? '...' : 'Add'}
          </button>
        </div>
      </div>

      <div className="space-y-2">
        <h2 className="text-white text-lg font-semibold mb-3">
          Players ({state.players.length})
        </h2>
        {state.loading ? (
          <p className="text-gray-400 text-center py-8">Loading...</p>
        ) : state.players.length === 0 ? (
          <p className="text-gray-400 text-center py-8 italic">
            No players yet. Add some names above!
          </p>
        ) : (
          <div className="space-y-2">
            {state.players.map((player) => (
              <div
                key={player.id}
                onClick={() => handleRemovePlayer(player.id)}
                className="flex items-center justify-between p-3 bg-gray-800 rounded-lg border border-gray-700 cursor-pointer hover:bg-gray-700 transition-colors"
              >
                <span className="text-white">{player.name}</span>
                <span className="text-red-400 text-sm">Tap to remove</span>
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  );
}

function DragDropTeam({ team, teamColor, onDrop, onRemove, title }) {
  const [dragOver, setDragOver] = useState(false);

  const handleDragOver = (e) => {
    e.preventDefault();
    setDragOver(true);
  };

  const handleDragLeave = (e) => {
    e.preventDefault();
    setDragOver(false);
  };

  const handleDrop = (e) => {
    e.preventDefault();
    setDragOver(false);
    const playerId = parseInt(e.dataTransfer.getData('text/plain'));
    onDrop(playerId);
  };

  const colorClasses = {
    orange: dragOver ? 'border-orange-300 bg-orange-500/20' : 'border-orange-500 bg-orange-500/10',
    green: dragOver ? 'border-green-300 bg-green-500/20' : 'border-green-500 bg-green-500/10'
  };

  return (
    <div 
      className={`flex-1 min-h-64 p-4 border-2 border-dashed rounded-lg transition-colors ${colorClasses[teamColor]}`}
      onDragOver={handleDragOver}
      onDragLeave={handleDragLeave}
      onDrop={handleDrop}
    >
      <h3 className={`text-lg font-bold mb-3 text-center ${teamColor === 'orange' ? 'text-orange-400' : 'text-green-400'}`}>
        {title} ({team.length})
      </h3>
      <div className="space-y-2">
        {team.map((player) => (
          <div
            key={player.id}
            className="p-2 bg-gray-800 rounded text-white text-center cursor-pointer hover:bg-gray-700 transition-colors relative group"
            onClick={() => onRemove(player.id)}
          >
            {player.name}
            <span className="absolute top-1 right-2 text-red-400 text-xs opacity-0 group-hover:opacity-100 transition-opacity">
              Ã—
            </span>
          </div>
        ))}
        {team.length === 0 && (
          <p className="text-gray-400 text-center py-8 italic">
            Drag players here
          </p>
        )}
      </div>
    </div>
  );
}

function TeamsTab() {
  const { state, moveToTeam, removeFromTeam, dispatch } = useApp();

  const handleDragStart = (e, playerId) => {
    e.dataTransfer.setData('text/plain', playerId.toString());
  };

  const handleMoveToOrange = async (playerId) => {
    await moveToTeam(playerId, 'orange');
  };

  const handleMoveToGreen = async (playerId) => {
    await moveToTeam(playerId, 'green');
  };

  const handleRemoveFromTeam = async (playerId) => {
    await removeFromTeam(playerId);
  };

  const availablePlayers = state.players.filter(
    player => !state.orangeTeam.find(p => p.id === player.id) && 
              !state.greenTeam.find(p => p.id === player.id)
  );

  return (
    <div className="p-4 max-w-4xl mx-auto">
      <ErrorBanner 
        error={state.error} 
        onDismiss={() => dispatch({ type: 'SET_ERROR', payload: null })} 
      />
      
      {/* Available Players */}
      <div className="mb-6">
        <h2 className="text-white text-lg font-semibold mb-3">
          Available Players ({availablePlayers.length})
        </h2>
        {state.loading ? (
          <p className="text-gray-400 text-center py-4">Loading...</p>
        ) : availablePlayers.length === 0 ? (
          <p className="text-gray-400 text-center py-4 italic">
            {state.players.length === 0 ? 'No players added yet. Go to Add/Remove tab to add players.' : 'All players are assigned to teams'}
          </p>
        ) : (
          <div className="flex flex-wrap gap-2">
            {availablePlayers.map((player) => (
              <div
                key={player.id}
                draggable
                onDragStart={(e) => handleDragStart(e, player.id)}
                className="px-3 py-2 bg-gray-700 text-white rounded-lg cursor-move hover:bg-gray-600 transition-colors select-none"
              >
                {player.name}
              </div>
            ))}
          </div>
        )}
      </div>

      {/* Teams */}
      <div className="flex gap-4 flex-col sm:flex-row">
        <DragDropTeam
          team={state.orangeTeam}
          teamColor="orange"
          onDrop={handleMoveToOrange}
          onRemove={handleRemoveFromTeam}
          title="ðŸŸ  Orange Team"
        />
        <DragDropTeam
          team={state.greenTeam}
          teamColor="green"
          onDrop={handleMoveToGreen}
          onRemove={handleRemoveFromTeam}
          title="ðŸŸ¢ Green Team"
        />
      </div>
    </div>
  );
}

function App() {
  const [activeTab, setActiveTab] = useState('add-remove');

  return (
    <AppProvider>
      <div className="min-h-screen bg-gray-900">
        <NavBar />
        <TabBar activeTab={activeTab} onTabChange={setActiveTab} />
        <main className="pb-4">
          {activeTab === 'add-remove' && <AddRemoveTab />}
          {activeTab === 'teams' && <TeamsTab />}
        </main>
      </div>
    </AppProvider>
  );
}

export default App;